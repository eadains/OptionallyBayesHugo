<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ergodicity Breaking and the Coin Toss Game | Optionally Bayes</title>
<meta name="keywords" content="ergodicity, stochastic-processes, monte-carlo">
<meta name="description" content="Revealing the strangeness of ergodicity breaking with a simple game">
<meta name="author" content="Erik Dains">
<link rel="canonical" href="http://eadains.github.io/OptionallyBayesHugo/posts/ergo_breaking/">
<link crossorigin="anonymous" href="/OptionallyBayesHugo/assets/css/stylesheet.bcfc03792d6caa596ec2d6e8f4e36ba32f6840d6e52e04254b294666b3f67ad2.css" integrity="sha256-vPwDeS1sqlluwtbo9ONroy9oQNblLgQlSylGZrP2etI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://eadains.github.io/OptionallyBayesHugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://eadains.github.io/OptionallyBayesHugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://eadains.github.io/OptionallyBayesHugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://eadains.github.io/OptionallyBayesHugo/apple-touch-icon.png">
<link rel="mask-icon" href="http://eadains.github.io/OptionallyBayesHugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://eadains.github.io/OptionallyBayesHugo/posts/ergo_breaking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</script>

  

<meta property="og:title" content="Ergodicity Breaking and the Coin Toss Game" />
<meta property="og:description" content="Revealing the strangeness of ergodicity breaking with a simple game" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://eadains.github.io/OptionallyBayesHugo/posts/ergo_breaking/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-08-03T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-08-03T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ergodicity Breaking and the Coin Toss Game"/>
<meta name="twitter:description" content="Revealing the strangeness of ergodicity breaking with a simple game"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://eadains.github.io/OptionallyBayesHugo/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Ergodicity Breaking and the Coin Toss Game",
      "item": "http://eadains.github.io/OptionallyBayesHugo/posts/ergo_breaking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ergodicity Breaking and the Coin Toss Game",
  "name": "Ergodicity Breaking and the Coin Toss Game",
  "description": "Revealing the strangeness of ergodicity breaking with a simple game",
  "keywords": [
    "ergodicity", "stochastic-processes", "monte-carlo"
  ],
  "articleBody": "Inspired by Ole Peters’ lovely blog post about this game and ergodicity breaking, I wanted to dive a little deeper into the mathematics of this to deepen my understanding. This concept is deep and subtle, so this simple game is a good place to start.\nDescription \u0026 Properties of the Game This coin flip game goes as follows: each round a coin is flipped with probability $p$ of landing heads, and when it comes heads you get a return of $G$ and when it lands tails you get a return of $L$. In other words, each round with probability $p$ your wealth is multiplied by a factor of $1+G$ and with probability $1-p$ your wealth is multiplied by a factor of $1+L$.\nWe can then start working out some basic properties of this game.\nFirst, given you’ve played $t$ rounds of the game, the probability that you win $w$ times is given by the binomial distribution: $$ P(t, w; p) = {t \\choose w} p^w (1-p)^{t-w} $$\nNext, given you have won $w$ times after player $t$ rounds, your terminal wealth is given by: $$ R(t, w; G, L) = (1+G)^w (1+L)^{t-w} $$ here, without loss of generality, we assume here that starting wealth is 1.\nNow, what can we say about expected wealth of a player after $t$ rounds? Following Peters, we have to differentiate between what he calls the ensemble average and the time average. Let’s start with the ensemble average. Here, this quantity matches what one usually thinks of when talking about mathematical expectation: multiply the probability of a game path by its terminal wealth. After $t$ rounds there are $t+1$ possible paths, each corresponding to the number of times a player could have won: $0$ to $t$ times. Now, given the above formulas, we can find this expectation, suppressing notation for the constant parameters $p$, $G$, and $L$: $$ \\text{EA}(t) = E_W \\left[ R(t, w) \\right] = \\sum_{w=0}^t P(t, w) R(t, w) $$\nLet’s consider the time average. As opposed to the ensemble average, which considers the possibilities over all possible paths, this average considers the expected behavior of a single path. We know from the properties of the binomial distribution that after $t$ rounds the expected number of wins is given by $pt$. So, for any single player, we expect that player to have won $pt$ times after playing for $t$ rounds. We can then work out this single players expected terminal wealth at that point: $$ \\text{TA}(t) = R(t, pt) = (1+G)^{pt} (1+L)^{t - pt} = ((1+G)^p (1+L)^{1-p})^t $$\nFrom this equation we can see that the term $(1+G)^p(1+L)^{1-p}$ determines the behavior of the time average as $t \\to \\infty$. If this term is $\u003e 1$ then a player’s wealth will tend towards $\\infty$, if it’s $=1$ then the player is expected to breakeven, and if it’s $\u003c1$ then the players wealth will tend towards 0. This means that we can determine, given either the loss or gain return, what the other must be so that the player is expected to break even. For example, given the winning return: $$ (1+G)^p (1+L)^{1-p} = 1 $$ $$ L = (1+G)^{\\frac{-p}{1-p}} - 1 $$\nErgodicity Breaking The entire idea of ergodicity breaking comes from the differences between these two formulas, namely the fact that they aren’t equal. The ensemble average can be interpreted as the average wealth of a group of players, as the number of people playing tends towards infinity. The time average, however, tells us what we expect the terminal wealth of any single player from that group to look like. In an ergodic system, these things are equal. This is to say that you can work out the properties of the entire system by following a single player, given enough time. However, that isn’t the case here. The system as a whole has a different behavior than that of any single player. This isn’t completely obvious from the formulas alone, but by running some game simulations, we can see how the ensemble and time averages diverge dramatically.\nFirst, we can encode the equations defined above:\nimport numpy as np from scipy.special import comb from scipy import stats import matplotlib.pyplot as plt rng = np.random.default_rng() def P(t, w, p): return comb(t, w) * p**w * (1 - p) ** (t - w) def R(t, w, G, L): return (1 + G) ** w * (1 + L) ** (t - w) def EA(t, G, L, p): sum = 0 for w in range(t + 1): sum += P(t, w, p) * R(t, w, G, L) return sum def TA(t, G, L, p): return ((1 + G) ** p * (1 + L) ** (1 - p)) ** t Then we can simulate game paths. My approach here is to generate a sequence of integers uniformly from the set ${0, 1}$ and treat each $1$ as a win and each $0$ as a loss. The wealth over time is then simply given by the cumulative product of the respective gain/loss factors:\ndef sim_path(t, G, L, p): game_hist = rng.choice([1.0, 0.0], t, p=[p, 1 - p]) game_hist[game_hist == 1] = 1 + G game_hist[game_hist == 0] = 1 + L return np.cumprod(game_hist) Setting the gain return to $50%$, the loss return to $-40%$, and of course we’ll treat this coin as fair so $p=0.5%$. We can then plot 50 different wealth paths after having played 1000 rounds of the game, along with our ensemble and time averages.\nG = 0.5 L = -0.4 p = 0.5 plt.plot( np.array([sim_path(1000, G, L, p) for x in range(50)]).T, color=\"black\", alpha=0.15 ) plt.plot([EA(t, G, L, p) for t in range(1000)], color=\"red\", label=\"EA(t)\") plt.plot([TA(t, G, L, p) for t in range(1000)], color=\"blue\", label=\"TA(t)\") plt.axhline(1, color=\"black\", linestyle=\"dashed\") plt.yscale(\"log\") plt.legend() plt.xlabel(\"t\") plt.ylabel(\"Terminal Wealth\") We can see right away the strangeness. All of the game paths end up losing money, following the negatively sloped time average line. However, the ensemble average tells us that the average wealth should be increasing! What gives? How can all of the players individually be expected to lose wealth over time, yet the ensemble average tells us that on the whole, the group should have increasing wealth? This is the insane mystery of ergodicity breaking.\nGoing Deeper Luckily for us, this game has simple mathematics, so we can get some nice theoretical results to shore up our intuition and understand what’s going on here.\nFirst of all, let’s see how many wins we need to get so that we expect to at least break even, in other words, we want $w$ such that $R(t, w) \\ge 1$. Doing some simple algebra, we can see that: $$ w \\ge -t \\frac{\\ln(1+L)}{\\ln(1+G) - \\ln(1+L)} := w_{\\text{BE}} $$\nFrom this we can work out the probability using the binominal distribution CDF, denoted $F$. Letting $W$ denote the random variable of how many wins we’ve got, we can see: $$ \\text{P}(W \\ge w_{\\text{BE}}) = 1 - F(w_{\\text{BE}}) $$\nWe can plot this probability over $t$ as follows:\ndef w_BE(t, G, L): return -t * np.log(1 + L) / (np.log(1 + G) - np.log(1 + L)) plt.plot([1 - stats.binom.cdf(k=w_BE(n, G, L), n=n, p=p) for n in range(1, 1000)]) plt.xlabel(\"t\") plt.ylabel(\"Probability\") We can see that as $t$ increases, the probability of at least breaking even decreases to 0. This explains why our time average has negative slope: as you play more and more, the probability that you end up at least breaking even asymptotically approaches zero. However, this does not explain why our ensemble average has positive slope. Let’s move to that next.\nFirst, let’s look at the average wealth of paths that are at least breaking even compared to the wealth of paths that are not. At a given time $t$, the function below computes the average wealth of all the possible game paths that are at or above break even, and the same for paths below break even.\ndef calc_wealths(t, G, L): w_be = w_BE(t, G, L) winning_wealth = [] losing_wealth = [] for w in range(t + 1): if w \u003c w_be: losing_wealth.append(R(t, w, G, L)) else: winning_wealth.append(R(t, w, G, L)) return np.mean(winning_wealth), np.mean(losing_wealth) wealths = [calc_wealths(t, G, L) for t in range(1, 100)] plt.plot([x[0] for x in wealths]) plt.plot([x[1] for x in wealths]) plt.legend([\"Winning Paths\", \"Losing Paths\"]) plt.yscale(\"log\") plt.xlabel(\"t\") plt.ylabel(\"Average Wealth\") We can see that the average wealth of winning paths is exponentially increasing (log-scale axes), while the average wealth of losing paths tends towards 0, as we would expect. This gives us a clue to the phenomena: the wealth of those winning paths is increasing so quickly that they are able to overcome the ever smaller probability of their occurrence, so when we aggregate them into the ensemble expectation, they alone are influential enough that it becomes positive. We can see this more clearly by looking at the relative contribution of each path to the ensemble average.\nFrom $\\text{EA}(t)$ we can see that it is the sum of the probability-weighted terminal wealth of each possible path. We can therefore compute the contribution of each term over the range of possible $w$ values, which is what we do below:\nt = 100 results = [] for w in range(t+1): path_prob = P(t, w, p) path_wealth = R(t, w, G, L) results.append(path_prob * path_wealth) Then, we can plot this curve, which we normalize so that each term is given as the percentage of the total, as well as include the line indicating the break-even number of wins $w_{\\text{BE}}$ computed above:\nplt.plot(range(t+1), np.array(results) / np.sum(results)) plt.axvline(w_BE(t, G, L), color=\"black\") plt.legend([\"Contribution\", \"Break Even Wins\"]) plt.xlabel(\"Number of Wins\") plt.ylabel(\"% of Total Expectation\") Here, we can see that the paths that contribute the most to the ensemble average are the winning paths! This is what causes the ensemble average to be positive: the biggest contributors to it are those paths that have gained wealth.\nOne interesting thing about this graph is that it’s not the paths that have won the absolute most that contribute heavily, but those that win just enough. Before I plotted this, I thought that the biggest contributors would be those paths with the largest number of wins, all the way to the right on the x-axis of this graph. The paths that say win more than 90% of the time have wealths that grow so exceptionally fast that I thought it would more than outweigh their exceptionally low probability of occurring. However, this is not the case!\nIt turns out that the probability-weighted terminal wealth simplifies nicely: $$ P(t, w) R(t, w) = {t \\choose w} p^w (1-p)^{t-w} (1+g)^w (1+L)^{t-w} $$ $$ = {t \\choose w} (p(1+G))^w ((1-p)(1+L))^{t-w} $$ which looks very much like a rescaled binominal distribution. So, we can work out its mode in a very similar way. This procedure gives us: $$ w_\\text{mode}(t) = \\frac{(1-p)(1+L) - t p (1+G)}{-p(1+G) - (1-p)(1+L)} $$ there is some subtlety around the fact that $w$ need be an integer that I’m ignoring here for simplicity. Regardless, we can add this line to our plot:\nmode = ((1-p) * (1+L) - t * p * (1+G)) / (-p*(1+G) - (1-p)*(1+L)) plt.plot(range(t+1), np.array(results) / np.sum(results)) plt.axvline(w_BE(t, G, L), color=\"black\") plt.axvline(mode, linestyle=\"dashed\", color=\"black\") plt.legend([\"Contribution\", \"Break Even Wins\", \"Mode\"]) plt.xlabel(\"Number of Wins\") plt.ylabel(\"% of Total Expectation\") We can go slightly further and convert this into a winning percentage by taking: $$ \\lim_{t \\to \\infty} \\frac{w_\\text{mode}(t)}{t} = \\lim_{t \\to \\infty} \\frac{(1-p)(1+L) - t p (1+G)}{-t p (1+G) - t (1-p)(1+L)} $$ $$ = \\lim_{t \\to \\infty} \\frac{\\frac{(1-p)(1+L) - t p (1+G)}{t} - p (1+G)}{-p(1+G) - (1-p)(1+L)} = \\frac{p(1+G)}{p(1+G) + (1-p)(1+L)} $$\npeak_win_pct = (p * (1+G)) / (p*(1+G) + (1-p)*(1+L)) print(peak_win_pct) 0.7142857142857143 which is about 70% with our parameters. So, we can say that really it’s the game paths that win around 70% of the time that are the ones that really push our ensemble average to be positive versus our time average.\nLet’s do one final exercise to see this effect a different way. We can compare the growth rates of the probability of a path and it’s wealth. This function computes the cumulative percentage change of those quantities in log space, in other words, their geometric growth rate. We take absolute values here because for the values we consider probabilities are decreasing and wealths are increasing, and we want to compare them on the same scale.\ndef prb_wealth_curves(win_pct, p, G, L): prbs = [] wealths = [] for t in range(1, 250): w = win_pct * t prbs.append(P(t, w, p)) wealths.append(R(t, w, G, L)) prbs = np.array(prbs) wealths = np.array(wealths) return ( np.abs(np.cumsum(np.diff(np.log(prbs), n=1))), np.abs(np.cumsum(np.diff(np.log(wealths), n=1))) ) First, we can look at these curve for the case where we win 70% of the time:\nprbs, wealths = prb_wealth_curves(0.70, 0.5, G, L) plt.plot(prbs) plt.plot(wealths) plt.legend([\"Probability\", \"Wealth\"]) plt.xlabel(\"t\") plt.ylabel(\"Cumulative Growth\") We see that at first, the probabilities are decreasing faster than wealth is increasing, but eventually wealth starts growing faster than the probabilities are decreasing, resulting in a large positive contribution to the ensemble average, as we saw above.\nNow, let’s look at paths that win 90% of the time:\nprbs, wealths = prb_wealth_curves(0.9, 0.5, G, L) plt.plot(prbs) plt.plot(wealths) plt.legend([\"Probability\", \"Wealth\"]) plt.xlabel(\"t\") plt.ylabel(\"Cumulative Growth\") Here we can see that right away the probabilities are decreasing faster than wealths are increasing, and this relationship holds, and indeed becomes more extreme, as time progresses. This results in the small contribution to the ensemble average.\nNow, in the case where we are winning below the break even rate, both the probabilities and wealths are decreasing, resulting in a contribution that shrinks very rapidly.\nConclusion This behavior is strange and very unintuitive to me, but it has enormous implications for how we think about many processes in the real world. Essentially, any process that follows a multiplicative reward structure will have this non-ergodic property. Notably, many economic systems have this kind of structure. Returns on capital are nearly always multiplicative: stock returns, GDP changes, certain gambling games, etcetera.\nIt’s almost immediate to see how this idea relates to income inequality. An economic system can be growing when considered as a whole, but much of that aggregate growth is coming from the exceptionally huge gains of an increasingly smaller subset of the people as time progresses. Obviously, in the real world the situation is much more complicated, but the principle is there. It’s interesting to think about the ultra-wealthy as nothing more than those people that happened to have gotten lucky with their investments compared to others. In fact, there is a noteworthy paper, “Wealth condensation in a simple model of economy,” that talks about this effect.\nNotably for financial economics, this exact same effect occurs if you move from discrete time to continuous time by analyzing Geometric Brownian Motion, and I’d like to get around to deriving how to move from a simple game like this to its continuous time counterpart. Stay tuned!\n",
  "wordCount" : "2471",
  "inLanguage": "en",
  "datePublished": "2024-08-03T00:00:00Z",
  "dateModified": "2024-08-03T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Erik Dains"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://eadains.github.io/OptionallyBayesHugo/posts/ergo_breaking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Optionally Bayes",
    "logo": {
      "@type": "ImageObject",
      "url": "http://eadains.github.io/OptionallyBayesHugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://eadains.github.io/OptionallyBayesHugo/" accesskey="h" title="Optionally Bayes (Alt + H)">Optionally Bayes</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://eadains.github.io/OptionallyBayesHugo/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://eadains.github.io/OptionallyBayesHugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://eadains.github.io/OptionallyBayesHugo/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://eadains.github.io/OptionallyBayesHugo/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Ergodicity Breaking and the Coin Toss Game
    </h1>
    <div class="post-meta"><span title='2024-08-03 00:00:00 +0000 UTC'>August 3, 2024</span>&nbsp;·&nbsp;Erik Dains

</div>
  </header> 
  <div class="post-content"><p>Inspired by Ole Peters&rsquo; <a href="https://ergodicityeconomics.com/2023/07/28/the-infamous-coin-toss/">lovely blog post</a> about this game and ergodicity breaking, I wanted to dive a little deeper into the mathematics of this to deepen my understanding. This concept is deep and subtle, so this simple game is a good place to start.</p>
<h1 id="description--properties-of-the-game">Description &amp; Properties of the Game<a hidden class="anchor" aria-hidden="true" href="#description--properties-of-the-game">#</a></h1>
<p>This coin flip game goes as follows: each round a coin is flipped with probability $p$ of landing heads, and when it comes heads you get a return of $G$ and when it lands tails you get a return of $L$. In other words, each round with probability $p$ your wealth is multiplied by a factor of $1+G$ and with probability $1-p$ your wealth is multiplied by a factor of $1+L$.</p>
<p>We can then start working out some basic properties of this game.</p>
<p>First, given you&rsquo;ve played $t$ rounds of the game, the probability that you win $w$ times is given by the binomial distribution:
$$
P(t, w; p) = {t \choose w} p^w (1-p)^{t-w}
$$</p>
<p>Next, given you have won $w$ times after player $t$ rounds, your terminal wealth is given by:
$$
R(t, w; G, L) = (1+G)^w (1+L)^{t-w}
$$
here, without loss of generality, we assume here that starting wealth is 1.</p>
<p>Now, what can we say about expected wealth of a player after $t$ rounds? Following Peters, we have to differentiate between what he calls the ensemble average and the time average. Let&rsquo;s start with the ensemble average. Here, this quantity matches what one usually thinks of when talking about mathematical expectation: multiply the probability of a game path by its terminal wealth. After $t$ rounds there are $t+1$ possible paths, each corresponding to the number of times a player could have won: $0$ to $t$ times. Now, given the above formulas, we can find this expectation, suppressing notation for the constant parameters $p$, $G$, and $L$:
$$
\text{EA}(t) = E_W \left[ R(t, w) \right] = \sum_{w=0}^t P(t, w) R(t, w)
$$</p>
<p>Let&rsquo;s consider the time average. As opposed to the ensemble average, which considers the possibilities over all possible paths, this average considers the expected behavior of a <em>single</em> path. We know from the properties of the binomial distribution that after $t$ rounds the expected number of wins is given by $pt$. So, for any single player, we expect that player to have won $pt$ times after playing for $t$ rounds. We can then work out this single players expected terminal wealth at that point:
$$
\text{TA}(t) = R(t, pt) = (1+G)^{pt} (1+L)^{t - pt} = ((1+G)^p (1+L)^{1-p})^t
$$</p>
<p>From this equation we can see that the term $(1+G)^p(1+L)^{1-p}$ determines the behavior of the time average as $t \to \infty$. If this term is $&gt; 1$ then a player&rsquo;s wealth will tend towards $\infty$, if it&rsquo;s $=1$ then the player is expected to breakeven, and if it&rsquo;s $&lt;1$ then the players wealth will tend towards 0. This means that we can determine, given either the loss or gain return, what the other must be so that the player is expected to break even. For example, given the winning return:
$$
(1+G)^p (1+L)^{1-p} = 1
$$
$$
L = (1+G)^{\frac{-p}{1-p}} - 1
$$</p>
<h1 id="ergodicity-breaking">Ergodicity Breaking<a hidden class="anchor" aria-hidden="true" href="#ergodicity-breaking">#</a></h1>
<p>The entire idea of ergodicity breaking comes from the differences between these two formulas, namely the fact that <em>they aren&rsquo;t equal</em>. The ensemble average can be interpreted as the average wealth of a group of players, as the number of people playing tends towards infinity. The time average, however, tells us what we expect the terminal wealth of any <em>single</em> player from that group to look like. In an ergodic system, these things are equal. This is to say that you can work out the properties of the entire system by following a single player, given enough time. However, that isn&rsquo;t the case here. The system as a whole has a different behavior than that of any single player. This isn&rsquo;t completely obvious from the formulas alone, but by running some game simulations, we can see how the ensemble and time averages diverge dramatically.</p>
<p>First, we can encode the equations defined above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy.special <span style="color:#f92672">import</span> comb
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy <span style="color:#f92672">import</span> stats
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rng <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>default_rng()
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">P</span>(t, w, p):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> comb(t, w) <span style="color:#f92672">*</span> p<span style="color:#f92672">**</span>w <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p) <span style="color:#f92672">**</span> (t <span style="color:#f92672">-</span> w)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">R</span>(t, w, G, L):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> G) <span style="color:#f92672">**</span> w <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> L) <span style="color:#f92672">**</span> (t <span style="color:#f92672">-</span> w)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">EA</span>(t, G, L, p):
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> range(t <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> P(t, w, p) <span style="color:#f92672">*</span> R(t, w, G, L)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">TA</span>(t, G, L, p):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ((<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> G) <span style="color:#f92672">**</span> p <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> L) <span style="color:#f92672">**</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p)) <span style="color:#f92672">**</span> t
</span></span></code></pre></div><p>Then we can simulate game paths. My approach here is to generate a sequence of integers uniformly from the set ${0, 1}$ and treat each $1$ as a win and each $0$ as a loss. The wealth over time is then simply given by the cumulative product of the respective gain/loss factors:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sim_path</span>(t, G, L, p):
</span></span><span style="display:flex;"><span>    game_hist <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>choice([<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>], t, p<span style="color:#f92672">=</span>[p, <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p])
</span></span><span style="display:flex;"><span>    game_hist[game_hist <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> G
</span></span><span style="display:flex;"><span>    game_hist[game_hist <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> L
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>cumprod(game_hist)
</span></span></code></pre></div><p>Setting the gain return to $50%$, the loss return to $-40%$, and of course we&rsquo;ll treat this coin as fair so $p=0.5%$. We can then plot 50 different wealth paths after having played 1000 rounds of the game, along with our ensemble and time averages.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>G <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>
</span></span><span style="display:flex;"><span>L <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.4</span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(
</span></span><span style="display:flex;"><span>    np<span style="color:#f92672">.</span>array([sim_path(<span style="color:#ae81ff">1000</span>, G, L, p) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">50</span>)])<span style="color:#f92672">.</span>T, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.15</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot([EA(t, G, L, p) <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1000</span>)], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;red&#34;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;EA(t)&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot([TA(t, G, L, p) <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1000</span>)], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;blue&#34;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;TA(t)&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axhline(<span style="color:#ae81ff">1</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dashed&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;t&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Terminal Wealth&#34;</span>)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./ergodicity_breaking_10_1.png#center"/> 
</figure>

<p>We can see right away the strangeness. All of the game paths end up losing money, following the negatively sloped time average line. However, the ensemble average tells us that the average wealth should be increasing! What gives? How can all of the players individually be expected to lose wealth over time, yet the ensemble average tells us that on the whole, the group should have increasing wealth? This is the insane mystery of ergodicity breaking.</p>
<h1 id="going-deeper">Going Deeper<a hidden class="anchor" aria-hidden="true" href="#going-deeper">#</a></h1>
<p>Luckily for us, this game has simple mathematics, so we can get some nice theoretical results to shore up our intuition and understand what&rsquo;s going on here.</p>
<p>First of all, let&rsquo;s see how many wins we need to get so that we expect to at least break even, in other words, we want $w$ such that $R(t, w) \ge 1$. Doing some simple algebra, we can see that:
$$
w \ge -t \frac{\ln(1+L)}{\ln(1+G) - \ln(1+L)} := w_{\text{BE}}
$$</p>
<p>From this we can work out the probability using the binominal distribution CDF, denoted $F$. Letting $W$ denote the random variable of how many wins we&rsquo;ve got, we can see:
$$
\text{P}(W \ge w_{\text{BE}}) = 1 - F(w_{\text{BE}})
$$</p>
<p>We can plot this probability over $t$ as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">w_BE</span>(t, G, L):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>t <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>log(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> L) <span style="color:#f92672">/</span> (np<span style="color:#f92672">.</span>log(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> G) <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>log(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> L))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot([<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> stats<span style="color:#f92672">.</span>binom<span style="color:#f92672">.</span>cdf(k<span style="color:#f92672">=</span>w_BE(n, G, L), n<span style="color:#f92672">=</span>n, p<span style="color:#f92672">=</span>p) <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1000</span>)])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;t&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Probability&#34;</span>)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./ergodicity_breaking_14_1.png#center"/> 
</figure>

<p>We can see that as $t$ increases, the probability of at least breaking even decreases to 0. This explains why our time average has negative slope: as you play more and more, the probability that you end up at least breaking even asymptotically approaches zero. However, this does not explain why our ensemble average has positive slope. Let&rsquo;s move to that next.</p>
<p>First, let&rsquo;s look at the average wealth of paths that <em>are</em> at least breaking even compared to the wealth of paths that are not. At a given time $t$, the function below computes the average wealth of all the possible game paths that are at or above break even, and the same for paths below break even.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calc_wealths</span>(t, G, L):
</span></span><span style="display:flex;"><span>    w_be <span style="color:#f92672">=</span> w_BE(t, G, L)
</span></span><span style="display:flex;"><span>    winning_wealth <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    losing_wealth <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> range(t <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> w <span style="color:#f92672">&lt;</span> w_be:
</span></span><span style="display:flex;"><span>            losing_wealth<span style="color:#f92672">.</span>append(R(t, w, G, L))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            winning_wealth<span style="color:#f92672">.</span>append(R(t, w, G, L))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>mean(winning_wealth), np<span style="color:#f92672">.</span>mean(losing_wealth)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>wealths <span style="color:#f92672">=</span> [calc_wealths(t, G, L) <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">100</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot([x[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> wealths])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot([x[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> wealths])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend([<span style="color:#e6db74">&#34;Winning Paths&#34;</span>, <span style="color:#e6db74">&#34;Losing Paths&#34;</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>yscale(<span style="color:#e6db74">&#34;log&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;t&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Average Wealth&#34;</span>)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./ergodicity_breaking_16_1.png#center"/> 
</figure>

<p>We can see that the average wealth of winning paths is exponentially increasing (log-scale axes), while the average wealth of losing paths tends towards 0, as we would expect. This gives us a clue to the phenomena: the wealth of those winning paths is increasing <em>so quickly</em> that they are able to overcome the ever smaller probability of their occurrence, so when we aggregate them into the ensemble expectation, they alone are influential enough that it becomes positive. We can see this more clearly by looking at the relative contribution of each path to the ensemble average.</p>
<p>From $\text{EA}(t)$ we can see that it is the sum of the probability-weighted terminal wealth of each possible path. We can therefore compute the contribution of each term over the range of possible $w$ values, which is what we do below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>t <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>results <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> range(t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    path_prob <span style="color:#f92672">=</span> P(t, w, p)
</span></span><span style="display:flex;"><span>    path_wealth <span style="color:#f92672">=</span> R(t, w, G, L)
</span></span><span style="display:flex;"><span>    results<span style="color:#f92672">.</span>append(path_prob <span style="color:#f92672">*</span> path_wealth)
</span></span></code></pre></div><p>Then, we can plot this curve, which we normalize so that each term is given as the percentage of the total, as well as include the line indicating the break-even number of wins $w_{\text{BE}}$ computed above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(range(t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), np<span style="color:#f92672">.</span>array(results) <span style="color:#f92672">/</span> np<span style="color:#f92672">.</span>sum(results))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(w_BE(t, G, L), color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend([<span style="color:#e6db74">&#34;Contribution&#34;</span>, <span style="color:#e6db74">&#34;Break Even Wins&#34;</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Number of Wins&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">% o</span><span style="color:#e6db74">f Total Expectation&#34;</span>)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./ergodicity_breaking_20_1.png#center"/> 
</figure>

<p>Here, we can see that the paths that contribute the most to the ensemble average are the winning paths! This is what causes the ensemble average to be positive: the biggest contributors to it are those paths that have gained wealth.</p>
<p>One interesting thing about this graph is that it&rsquo;s not the paths that have won the absolute most that contribute heavily, but those that win just enough. Before I plotted this, I thought that the biggest contributors would be those paths with the largest number of wins, all the way to the right on the x-axis of this graph. The paths that say win more than 90% of the time have wealths that grow so exceptionally fast that I thought it would more than outweigh their exceptionally low probability of occurring. However, this is not the case!</p>
<p>It turns out that the probability-weighted terminal wealth simplifies nicely:
$$
P(t, w) R(t, w) = {t \choose w} p^w (1-p)^{t-w} (1+g)^w (1+L)^{t-w}
$$
$$
= {t \choose w} (p(1+G))^w ((1-p)(1+L))^{t-w}
$$
which looks very much like a rescaled binominal distribution. So, we can work out its mode in a very <a href="https://math.stackexchange.com/questions/117926/finding-mode-in-binomial-distribution">similar way</a>. This procedure gives us:
$$
w_\text{mode}(t) = \frac{(1-p)(1+L) - t p (1+G)}{-p(1+G) - (1-p)(1+L)}
$$
there is some subtlety around the fact that $w$ need be an integer that I&rsquo;m ignoring here for simplicity. Regardless, we can add this line to our plot:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>mode <span style="color:#f92672">=</span> ((<span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>p) <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>L) <span style="color:#f92672">-</span> t <span style="color:#f92672">*</span> p <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>G)) <span style="color:#f92672">/</span> (<span style="color:#f92672">-</span>p<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>G) <span style="color:#f92672">-</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>p)<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>L))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(range(t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), np<span style="color:#f92672">.</span>array(results) <span style="color:#f92672">/</span> np<span style="color:#f92672">.</span>sum(results))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(w_BE(t, G, L), color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(mode, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dashed&#34;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend([<span style="color:#e6db74">&#34;Contribution&#34;</span>, <span style="color:#e6db74">&#34;Break Even Wins&#34;</span>, <span style="color:#e6db74">&#34;Mode&#34;</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Number of Wins&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">% o</span><span style="color:#e6db74">f Total Expectation&#34;</span>)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./ergodicity_breaking_22_1.png#center"/> 
</figure>

<p>We can go slightly further and convert this into a winning percentage by taking:
$$
\lim_{t \to \infty} \frac{w_\text{mode}(t)}{t} = \lim_{t \to \infty} \frac{(1-p)(1+L) - t p (1+G)}{-t p (1+G) - t (1-p)(1+L)}
$$
$$
= \lim_{t \to \infty} \frac{\frac{(1-p)(1+L) - t p (1+G)}{t} - p (1+G)}{-p(1+G) - (1-p)(1+L)} = \frac{p(1+G)}{p(1+G) + (1-p)(1+L)}
$$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>peak_win_pct <span style="color:#f92672">=</span> (p <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>G)) <span style="color:#f92672">/</span> (p<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>G) <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>p)<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>L))
</span></span><span style="display:flex;"><span>print(peak_win_pct)
</span></span></code></pre></div><pre><code>0.7142857142857143
</code></pre>
<p>which is about 70% with our parameters. So, we can say that really it&rsquo;s the game paths that win around 70% of the time that are the ones that really push our ensemble average to be positive versus our time average.</p>
<p>Let&rsquo;s do one final exercise to see this effect a different way. We can compare the growth rates of the probability of a path and it&rsquo;s wealth. This function computes the cumulative percentage change of those quantities in log space, in other words, their geometric growth rate. We take absolute values here because for the values we consider probabilities are decreasing and wealths are increasing, and we want to compare them on the same scale.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prb_wealth_curves</span>(win_pct, p, G, L):
</span></span><span style="display:flex;"><span>    prbs <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    wealths <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">250</span>):
</span></span><span style="display:flex;"><span>        w <span style="color:#f92672">=</span> win_pct <span style="color:#f92672">*</span> t
</span></span><span style="display:flex;"><span>        prbs<span style="color:#f92672">.</span>append(P(t, w, p))
</span></span><span style="display:flex;"><span>        wealths<span style="color:#f92672">.</span>append(R(t, w, G, L))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    prbs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(prbs)
</span></span><span style="display:flex;"><span>    wealths <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(wealths)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>        np<span style="color:#f92672">.</span>abs(np<span style="color:#f92672">.</span>cumsum(np<span style="color:#f92672">.</span>diff(np<span style="color:#f92672">.</span>log(prbs), n<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))),
</span></span><span style="display:flex;"><span>        np<span style="color:#f92672">.</span>abs(np<span style="color:#f92672">.</span>cumsum(np<span style="color:#f92672">.</span>diff(np<span style="color:#f92672">.</span>log(wealths), n<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)))
</span></span><span style="display:flex;"><span>        )
</span></span></code></pre></div><p>First, we can look at these curve for the case where we win 70% of the time:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>prbs, wealths <span style="color:#f92672">=</span> prb_wealth_curves(<span style="color:#ae81ff">0.70</span>, <span style="color:#ae81ff">0.5</span>, G, L)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(prbs)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(wealths)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend([<span style="color:#e6db74">&#34;Probability&#34;</span>, <span style="color:#e6db74">&#34;Wealth&#34;</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;t&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Cumulative Growth&#34;</span>)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./ergodicity_breaking_28_1.png#center"/> 
</figure>

<p>We see that at first, the probabilities are decreasing faster than wealth is increasing, but eventually wealth starts growing faster than the probabilities are decreasing, resulting in a large positive contribution to the ensemble average, as we saw above.</p>
<p>Now, let&rsquo;s look at paths that win 90% of the time:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>prbs, wealths <span style="color:#f92672">=</span> prb_wealth_curves(<span style="color:#ae81ff">0.9</span>, <span style="color:#ae81ff">0.5</span>, G, L)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(prbs)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(wealths)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend([<span style="color:#e6db74">&#34;Probability&#34;</span>, <span style="color:#e6db74">&#34;Wealth&#34;</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;t&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Cumulative Growth&#34;</span>)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./ergodicity_breaking_30_1.png#center"/> 
</figure>

<p>Here we can see that right away the probabilities are decreasing faster than wealths are increasing, and this relationship holds, and indeed becomes more extreme, as time progresses. This results in the small contribution to the ensemble average.</p>
<p>Now, in the case where we are winning below the break even rate, both the probabilities and wealths are decreasing, resulting in a contribution that shrinks very rapidly.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>This behavior is strange and very unintuitive to me, but it has enormous implications for how we think about many processes in the real world. Essentially, any process that follows a multiplicative reward structure will have this non-ergodic property. Notably, many economic systems have this kind of structure. Returns on capital are nearly always multiplicative: stock returns, GDP changes, certain gambling games, etcetera.</p>
<p>It&rsquo;s almost immediate to see how this idea relates to income inequality. An economic system can be growing when considered as a whole, but much of that aggregate growth is coming from the exceptionally huge gains of an increasingly smaller subset of the people as time progresses. Obviously, in the real world the situation is much more complicated, but the principle is there. It&rsquo;s interesting to think about the ultra-wealthy as nothing more than those people that happened to have gotten lucky with their investments compared to others. In fact, there is a noteworthy paper, &ldquo;<a href="https://arxiv.org/abs/cond-mat/0002374">Wealth condensation in a simple model of economy</a>,&rdquo; that talks about this effect.</p>
<p>Notably for financial economics, this exact same effect occurs if you move from discrete time to continuous time by analyzing Geometric Brownian Motion, and I&rsquo;d like to get around to deriving how to move from a simple game like this to its continuous time counterpart. Stay tuned!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://eadains.github.io/OptionallyBayesHugo/tags/ergodicity/">Ergodicity</a></li>
      <li><a href="http://eadains.github.io/OptionallyBayesHugo/tags/stochastic-processes/">Stochastic-Processes</a></li>
      <li><a href="http://eadains.github.io/OptionallyBayesHugo/tags/monte-carlo/">Monte-Carlo</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://eadains.github.io/OptionallyBayesHugo/">Optionally Bayes</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>

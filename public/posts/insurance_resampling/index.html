<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="light">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Bayesian Method for Insurance Policy Resampling | Optionally Bayes</title>
<meta name="keywords" content="python, bayesian, insurance, pymc, arviz">
<meta name="description" content="Using pymc to build a model to provide posterior samples of policy-level claim and severity estimates">
<meta name="author" content="Erik Dains">
<link rel="canonical" href="http://eadains.github.io/OptionallyBayesHugo/posts/insurance_resampling/">
<link crossorigin="anonymous" href="/OptionallyBayesHugo/assets/css/stylesheet.c9234ac2d086ecbdd4818d8373c4b7dcc4c7e8da6f8d5ff01f3e2b24a8b382ab.css" integrity="sha256-ySNKwtCG7L3UgY2Dc8S33MTH6NpvjV/wHz4rJKizgqs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://eadains.github.io/OptionallyBayesHugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://eadains.github.io/OptionallyBayesHugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://eadains.github.io/OptionallyBayesHugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://eadains.github.io/OptionallyBayesHugo/apple-touch-icon.png">
<link rel="mask-icon" href="http://eadains.github.io/OptionallyBayesHugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://eadains.github.io/OptionallyBayesHugo/posts/insurance_resampling/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</script>
<meta property="og:url" content="http://eadains.github.io/OptionallyBayesHugo/posts/insurance_resampling/">
  <meta property="og:site_name" content="Optionally Bayes">
  <meta property="og:title" content="Bayesian Method for Insurance Policy Resampling">
  <meta property="og:description" content="Using pymc to build a model to provide posterior samples of policy-level claim and severity estimates">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-31T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-31T00:00:00+00:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Bayesian">
    <meta property="article:tag" content="Insurance">
    <meta property="article:tag" content="Pymc">
    <meta property="article:tag" content="Arviz">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bayesian Method for Insurance Policy Resampling">
<meta name="twitter:description" content="Using pymc to build a model to provide posterior samples of policy-level claim and severity estimates">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://eadains.github.io/OptionallyBayesHugo/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Bayesian Method for Insurance Policy Resampling",
      "item": "http://eadains.github.io/OptionallyBayesHugo/posts/insurance_resampling/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Bayesian Method for Insurance Policy Resampling",
  "name": "Bayesian Method for Insurance Policy Resampling",
  "description": "Using pymc to build a model to provide posterior samples of policy-level claim and severity estimates",
  "keywords": [
    "python", "bayesian", "insurance", "pymc", "arviz"
  ],
  "articleBody": "One of the problems with insurance data is that you only get one go at observing losses for a given policy in a given year. You can debate this epistemically, but in my mind the “true” claim frequency or claim severity for a policy in a given year is a latent, unobserved quantity. The only thing you actually observe as an insurer is the policy characteristics, total claim count, and total claim amount. Inferring the true underlying frequency or severity is then a statistical exercise. A useful question to ask is, given the claims we saw, what is a reasonable range of claims we could have seen? This is the question I’ll provide at least an introduction to here.\nThe Inference Model import arviz as az import lightgbm as lgb import matplotlib.pyplot as plt import numpy as np import polars as pl import pymc as pm from scipy import stats from sklearn.compose import make_column_transformer from sklearn.model_selection import train_test_split from sklearn.preprocessing import OrdinalEncoder I’ll be using a freely available French auto liability dataset for this. There’s some preprocessing necessary to get the data together:\ndf_freq = pl.read_csv(\"./data/insurance/freMTPL2freq.csv\") df_sev = pl.read_csv(\"./data/insurance/freMTPL2sev.csv\", infer_schema_length=None).group_by(\"IDpol\").sum() df = df_freq.join(df_sev, on=\"IDpol\", how=\"left\", coalesce=True).with_columns(pl.col(\"ClaimAmount\").fill_null(0)) df_sample = df.sample(5000, seed=42) Now, to infer latent quantities we have to assume a probabilistic model for what we do actually observe. I think this model is about as simple as you can get. The general idea is to first model claim count and claim severity separately. For claim counts we assume they follow a Poisson distribution with a mean equal to the policy exposure times the claim frequency (claims per exposure). We assume claim severity (loss dollars per claim) follows an Exponential distribution. You could easily assume other functional forms here, like log-normal, but for a strictly positive variable with a specified mean, the Exponential distribution is the maximum entropy distribution.\nThe critical piece here is that we estimate the frequency and severity parameters individually for each policy, where we have a hyperprior for both to reduce the total effective number of parameters. This is the notation for the model: $$ \\begin{align*} C_i \u0026\\sim \\text{Poisson}(\\mu=\\lambda_i \\text{E}_i) \\newline S_i \u0026\\sim \\text{Exponential}\\left(\\lambda=\\frac{1}{\\mu_i C_i} \\right) \\newline \\lambda_i \u0026\\sim \\text{Exponential}(\\lambda=\\phi) \\newline \\mu_i \u0026\\sim \\text{Exponential}({\\lambda=\\omega}) \\newline \\phi \u0026\\sim \\text{Exponential}(\\lambda=1) \\newline \\omega \u0026\\sim \\text{Exponential}({\\lambda=1}) \\end{align*} $$\nWhere $i$ indexes each policy, $C$ and $S$ represent the observed claim count and total loss amount, respectively, and $\\text{E}$ represents the policy exposure. By multiplying $\\lambda$ and $\\text{E}$, we assume that the total number of claims is the policy exposure times the claim frequency, defined as the number of claims per unit of exposure, so we can interpret $\\lambda$ as the policy’s estimated claim frequency. We set the mean of the Exponential distribution for $S$ to be the observed claim amount $C$ times $\\mu$, so we can similarly interpret $\\mu$ as the policy’s estimated claim severity, the amount of loss dollars incurred per claim.\nWe can express this in pymc as follows. Note that we only apply the likelihood for the loss amount when it is above 0, because a total loss amount of 0 doesn’t tell us anything about the severity for the policy, as that happens when we have 0 claims. So, a 0 claim count is informative for our estimate of the claim frequency, but gives us no information about that policy’s claim severity, since we didn’t actually observe any losses. This becomes a key aspect of how this model works: for claims where we haven’t observed any losses we can still take a guess at its claim severity because of the hyperprior.\nN = len(df_sample) E = df_sample[\"Exposure\"].to_numpy() C = df_sample[\"ClaimNb\"].to_numpy() S = df_sample[\"ClaimAmount\"].to_numpy() with pm.Model() as model: phi = pm.Exponential(\"phi\", lam=1.0) omega = pm.Exponential(\"omega\", lam=1.0) lam = pm.Exponential(\"lambda\", lam=phi, shape=N) mu = pm.Exponential(\"mu\", lam=omega, shape=N) c_obs = pm.Poisson(\"C\", mu=E * lam, observed=C) mask = S \u003e 0 severity_rate = 1.0 / (mu[mask] * C[mask]) s_obs = pm.Exponential(\"S\", lam=severity_rate, observed=S[mask]) trace = pm.sample(draws=1000, tune=1000, chains=4) trace.extend(pm.sample_posterior_predictive(trace)) trace.extend(pm.compute_log_likelihood(trace)) We can then look at some model diagnostics to see if our MCMC converged well. First, we can look at the chain samples and posterior distribution for our hyperprior variables:\naz.plot_trace(trace, var_names=[\"phi\", \"omega\"]) $\\omega$ is not sampling as well as $\\phi$ but it looks okay.\nNext we can then visualize the energy transition distribution to see if it looks okay:\naz.plot_energy(trace) And the two distributions match, meaning we expect it to have adequately explored the posterior space.\nNow, let’s look at some diagnostics related to the posterior predictive distributions of $C$ and $S$. First, we expect, a priori, higher exposure policies to contain more information. This is because of a natural assumption about insurance policies that they can be “decomposed” in a certain sense. Here, our exposure is car-years, meaning that if a policy has an exposure of 2, that could be 2 cars for 1 year, or 1 car for 2 years, or some combination. So, one can think of a policy with exposure 2 as being equivalent, from a risk standpoint, as 2 policies both with exposure 1. Holding policy characteristics constant, and glossing over details of deductibles and whatnot, there’s no difference between a single policy covering 2 vehicles and 2 separate policies each covering one of them, the expected losses are the same. You can think through the same logic for home insurance and the like.\nSo, if we think of exposure in this way, it means that policies can be thought of as sums of random variables where each random variable represents a risk with unit exposure. Focusing on claim counts, imagine each of these unit exposure random variables follows a Poisson distribution with mean $\\mu$. Then, the total expected claim count for a policy with exposure $N$ is simply $\\mu * N$, and, more importantly, the variance of the mean is $\\frac{\\mu}{\\sqrt{N}}$ (from the fact that the variance and mean of a Poisson distribution are equal). Therefore, as $N$, total exposure, increases, we expect the variance of our estimate of the expected total claim count to go down. With some mathematical rearrangement you can see that this same idea applies to an estimate of the claim frequency rather than just total number of claims. Regardless, we can just see if this is true from our posterior samples:\nstats.pearsonr(df_sample[\"Exposure\"], az.extract(trace, var_names=[\"lambda\"]).var(axis=1)) PearsonRResult(statistic=np.float64(-0.2568976199074987), pvalue=np.float64(3.488038665730237e-76)) Here we are measuring the degree of correlation between the exposure values and the variance of the samples for the claim frequency for each policy. The negative correlation we observe is exactly as we’d expect: larger exposure policies have a lower variance in their estimated claim frequency.\nNext, we can compare the total number of claims in the dataset to our posterior distribution of the same. We expect the observed number of claims to fall in some high probability region of our posterior, which tells us that what we observe matches up with what the model is telling us:\nplt.hist(az.extract(trace.posterior_predictive, var_names=[\"C\"]).sum(axis=0), bins=25, color=\"grey\") plt.axvline(df_sample[\"ClaimNb\"].sum(), color=\"red\") plt.xlabel(\"Total Number of Claims\") plt.ylabel(\"Density\") plt.title(\"Histogram of Sampled Claim Counts\") plt.legend([\"Observed Total\", \"Sampled Data\"]) We can see that things look quite reasonable.\nWe can do the same analysis for the total loss:\nplt.hist(az.extract(trace.posterior_predictive, var_names=[\"S\"]).sum(axis=0), bins=25, color=\"grey\") plt.axvline(df_sample[\"ClaimAmount\"].sum(), color=\"red\") plt.xlabel(\"Total Loss Amount\") plt.ylabel(\"Density\") plt.title(\"Histogram of Sampled Loss Amounts\") plt.legend([\"Observed Total\", \"Sampled Data\"]) Our observed total loss amount lies a little to the right of the mode of our posterior distribution, but still lies in a reasonable area.\nNext, let’s compare the posterior claim frequency of a policy where we actually have observed claims to one where we observe zero claims:\n# Comparing the posterior distributions of policies with high/low observed frequency lam_sample = az.extract(trace, var_names=\"lambda\") high_claim = lam_sample[df_sample[\"ClaimNb\"].to_numpy().argmax()] low_claim = lam_sample[df_sample[\"ClaimNb\"].to_numpy().argmin()] plt.hist(high_claim, bins=25, alpha=0.5, color=\"black\") plt.hist(low_claim, bins=25, alpha=0.5, color=\"red\") plt.axvline(high_claim.mean(), color=\"black\") plt.axvline(low_claim.mean(), color=\"red\") plt.xlabel(\"Sampled Frequency\") plt.ylabel(\"Density\") plt.legend([\"High Obs Claims\", \"Low Obs Claims\"]) You can see that, as we’d expect, when we have actually observed claims for a policy, our estimate of its claim frequency goes up.\nFrom these basic diagnostics, we can see that our model reflects the stylized facts of insurance data that we expect to see. Note that this is a very simple model, you can increase the complexity from here. For example, this model assumes that our estimate of the true latent frequency and severity depends only upon our observed values for each, and no other policy characteristics. You can easily see how other specific information about the claim would affect your guess of its true frequency or severity.\nPredictive Model and Lift Charts I want to demonstrate one potentially useful application of a model like this, which is putting error bounds on lift charts. Typically, in insurance modeling applications, you create a lift chart that compares your modeled predictions of total claims or losses to the actually observed quantities. However, as we said at the beginning, the observed quantities only represent a single observation per policy. By using the posterior we computed above, we can now compute an expected range of observed claims and losses, so we can add some error bars to our lift chart, which lets us see probabilistically how our predictions stack up.\nModel predictions and actual observations will never perfectly match up on a lift chart, so a natural question to ask is: how far away can my predicted quantity be from the observed before it’s unreasonable? And that question is what the lift chart I develop below is able to give some clue to.\nFirst, we develop a very basic lightgbm model to predict claim counts given the policy-specific characteristics in the dataset:\ntransformer = make_column_transformer( ( OrdinalEncoder(handle_unknown=\"use_encoded_value\", unknown_value=np.nan), [\"Area\", \"VehBrand\", \"VehGas\", \"Region\"], ), (\"passthrough\", [\"Exposure\", \"VehPower\", \"VehAge\", \"DrivAge\", \"BonusMalus\", \"Density\"]), remainder=\"drop\", ) X = transformer.fit_transform(df) y = df[\"ClaimNb\"].to_numpy() train_X, val_X, train_y, val_y = train_test_split(X, y, test_size=0.20) claims_model = lgb.LGBMRegressor( learning_rate=0.1, n_estimators=10000, objective=\"poisson\", subsample=0.50, subsample_freq=1, colsample_bytree=0.5, max_depth=6, num_leaves=2**6 - 1, extra_trees=True, ) claims_model.fit( train_X, train_y, eval_set=(val_X, val_y), callbacks=[lgb.early_stopping(stopping_rounds=50)], categorical_feature=[0, 1, 2, 3], ) We can look at some SHAP scatter charts to get a sense of how our input variables affect our predictions:\nimport shap explainer = shap.TreeExplainer(claims_model.booster_, feature_names=transformer.get_feature_names_out()) shap_values = explainer(val_X[: int(len(val_X) * 0.10)]) shap.plots.scatter( shap_values[:, [\"passthrough__Exposure\", \"passthrough__DrivAge\", \"passthrough__BonusMalus\"]], shap_values ) Then, we can assemble our values for the lift chart. First we compute our quantile bin cutoffs, and then for each bin we compute the total predicted claim count plus some estimated quantiles of observed claim counts using the posterior distribution from the inference model:\n(Note that the searchsorted trick here is quite nice. The list of quantiles is sorted by definition, and searchsorted returns the index of the quantiles array for each value of the predictions array that value would have to be placed to maintain its order. So, for instance if quantiles is [1, 2], then any prediction \u003c= 1 would be assigned index 0, anything \u003e1 but \u003c= 2 would be assigned index 1, and anything greater than 2 would be assigned index 2. So, to find all values in the predictions array that are in the first quantile bin, i.e. \u003c1, we just have to find which elements of the array returned by searchsorted are equal to 0, as so on for the other bins.)\npredictions = claims_model.predict(transformer.transform(df_sample)) qs = np.linspace(1 / 5, 1, 4, endpoint=False) quantiles = np.quantile(predictions, qs) sampled_freqs = az.extract(trace, group=\"posterior\", var_names=\"lambda\") exposures = df_sample[\"Exposure\"].to_numpy() actual_claims = df_sample[\"ClaimNb\"].to_numpy() results = {} for idx in range(len(quantiles) + 1): # This searchsorted trick is quite clever: subset_idx = np.searchsorted(quantiles, predictions) == idx claims_subset = actual_claims[subset_idx] freqs_subset = sampled_freqs[subset_idx] exposures_subset = exposures[subset_idx] results[idx] = { \"predicted\": claims_subset.sum(), # Note that these calculations are the same as multiplying all of the sampled freqs and exposures together and then taking the quantile \"q25\": (np.quantile(freqs_subset, 0.25, axis=1) * exposures_subset).sum(), \"median\": (np.quantile(freqs_subset, 0.50, axis=1) * exposures_subset).sum(), \"q75\": (np.quantile(freqs_subset, 0.75, axis=1) * exposures_subset).sum(), } fig, ax = plt.subplots(figsize=(10, 6)) bins = sorted(list(results.keys())) x_positions = np.arange(len(bins)) medians = [results[bin_idx][\"median\"] for bin_idx in bins] q25s = [results[bin_idx][\"q25\"] for bin_idx in bins] q75s = [results[bin_idx][\"q75\"] for bin_idx in bins] predictions = [results[bin_idx][\"predicted\"] for bin_idx in bins] ranges = ax.vlines( x_positions, q25s, q75s, color=\"cornflowerblue\", alpha=0.7, linewidth=3, label=\"25th-75th Percentile Range\" ) median_dots = ax.scatter(x_positions, medians, color=\"navy\", s=80, zorder=3, label=\"Median\") pred_dots = ax.scatter(x_positions, predictions, color=\"crimson\", marker=\"X\", s=100, zorder=3, label=\"Predicted\") ax.set_xticks(x_positions) ax.set_xticklabels([f\"Bin {bin_idx}\" for bin_idx in bins]) ax.set_xlabel(\"Bin\", fontsize=12) ax.set_ylabel(\"Total Claims\", fontsize=12) ax.set_title(\"Predicted Values vs. Quantile Ranges by Bin\", fontsize=14) ax.legend(handles=[ranges, median_dots, pred_dots], loc=\"upper left\") ax.grid(True, linestyle=\"--\", alpha=0.7) ax.set_axisbelow(True) plt.tight_layout() Here we can see that for each bin, we marked the model predicted total claim count, as well as the 25th, median, and 75th percentile total claim counts computed from our inference model. We can see that for bins 0 through 3, our predictions sit nicely towards the middle of the expected claims distribution. However, for bin 4, our predicted values lies past the quantile boundaries, meaning that we over-predict claim counts for policies in that bin.\nThis kind of visualization gives you more information about how reasonable your predicted values are compared to the entire posterior distribution of observed claims. Of course, you can do the same kind of thing for total losses, severity, etc. See, for instance, that in bin 1 our predicted value does get away from the median moreso than some of the other bins, but the quantile boundaries tell you that it’s not really that off.\nConclusion Hopefully this is illustrative, but I think a model like this is very useful for placing your expectations about your historical policy experience in a nice framework. I don’t think what we actually observed in the past is the end of the story for insurance, even putting aside development issues, which is another thing you could expand this model to incorporate. The past only gives us a single pass of experience, but we can still use that information to make pretty good guesses about what could have happened.\n",
  "wordCount" : "2294",
  "inLanguage": "en",
  "datePublished": "2026-01-31T00:00:00Z",
  "dateModified": "2026-01-31T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Erik Dains"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://eadains.github.io/OptionallyBayesHugo/posts/insurance_resampling/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Optionally Bayes",
    "logo": {
      "@type": "ImageObject",
      "url": "http://eadains.github.io/OptionallyBayesHugo/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://eadains.github.io/OptionallyBayesHugo/" accesskey="h" title="Optionally Bayes (Alt + H)">Optionally Bayes</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://eadains.github.io/OptionallyBayesHugo/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://eadains.github.io/OptionallyBayesHugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://eadains.github.io/OptionallyBayesHugo/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://eadains.github.io/OptionallyBayesHugo/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Bayesian Method for Insurance Policy Resampling
    </h1>
    <div class="post-meta"><span title='2026-01-31 00:00:00 +0000 UTC'>January 31, 2026</span>&nbsp;·&nbsp;<span>Erik Dains</span>

</div>
  </header> 
  <div class="post-content"><p>One of the problems with insurance data is that you only get one go at observing losses for a given policy in a given year. You can debate this epistemically, but in my mind the &ldquo;true&rdquo; claim frequency or claim severity for a policy in a given year is a latent, unobserved quantity. The only thing you actually observe as an insurer is the policy characteristics, total claim count, and total claim amount. Inferring the true underlying frequency or severity is then a statistical exercise. A useful question to ask is, given the claims we saw, what is a reasonable range of claims we <em>could</em> have seen? This is the question I&rsquo;ll provide at least an introduction to here.</p>
<h1 id="the-inference-model">The Inference Model<a hidden class="anchor" aria-hidden="true" href="#the-inference-model">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> arviz <span style="color:#66d9ef">as</span> az
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> lightgbm <span style="color:#66d9ef">as</span> lgb
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> polars <span style="color:#66d9ef">as</span> pl
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pymc <span style="color:#66d9ef">as</span> pm
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy <span style="color:#f92672">import</span> stats
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.compose <span style="color:#f92672">import</span> make_column_transformer
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.model_selection <span style="color:#f92672">import</span> train_test_split
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.preprocessing <span style="color:#f92672">import</span> OrdinalEncoder
</span></span></code></pre></div><p>I&rsquo;ll be using a freely available French auto liability <a href="https://www.kaggle.com/datasets/floser/french-motor-claims-datasets-fremtpl2freq">dataset</a> for this. There&rsquo;s some preprocessing necessary to get the data together:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df_freq <span style="color:#f92672">=</span> pl<span style="color:#f92672">.</span>read_csv(<span style="color:#e6db74">&#34;./data/insurance/freMTPL2freq.csv&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>df_sev <span style="color:#f92672">=</span> pl<span style="color:#f92672">.</span>read_csv(<span style="color:#e6db74">&#34;./data/insurance/freMTPL2sev.csv&#34;</span>, infer_schema_length<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>)<span style="color:#f92672">.</span>group_by(<span style="color:#e6db74">&#34;IDpol&#34;</span>)<span style="color:#f92672">.</span>sum()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>df <span style="color:#f92672">=</span> df_freq<span style="color:#f92672">.</span>join(df_sev, on<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;IDpol&#34;</span>, how<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;left&#34;</span>, coalesce<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>with_columns(pl<span style="color:#f92672">.</span>col(<span style="color:#e6db74">&#34;ClaimAmount&#34;</span>)<span style="color:#f92672">.</span>fill_null(<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>df_sample <span style="color:#f92672">=</span> df<span style="color:#f92672">.</span>sample(<span style="color:#ae81ff">5000</span>, seed<span style="color:#f92672">=</span><span style="color:#ae81ff">42</span>)
</span></span></code></pre></div><p>Now, to infer latent quantities we have to assume a probabilistic model for what we do actually observe. I think this model is about as simple as you can get. The general idea is to first model claim count and claim severity separately. For claim counts we assume they follow a Poisson distribution with a mean equal to the policy exposure times the claim frequency (claims per exposure). We assume claim severity (loss dollars per claim) follows an Exponential distribution. You could easily assume other functional forms here, like log-normal, but for a strictly positive variable with a specified mean, the Exponential distribution is the <a href="https://en.wikipedia.org/wiki/Maximum_entropy_probability_distribution">maximum entropy distribution</a>.</p>
<p>The critical piece here is that we estimate the frequency and severity parameters <em>individually</em> for each policy, where we have a hyperprior for both to reduce the total effective number of parameters. This is the notation for the model:
$$
\begin{align*}
C_i &amp;\sim \text{Poisson}(\mu=\lambda_i \text{E}_i) \newline
S_i &amp;\sim \text{Exponential}\left(\lambda=\frac{1}{\mu_i C_i} \right) \newline
\lambda_i &amp;\sim \text{Exponential}(\lambda=\phi) \newline
\mu_i &amp;\sim \text{Exponential}({\lambda=\omega}) \newline
\phi &amp;\sim \text{Exponential}(\lambda=1) \newline
\omega &amp;\sim \text{Exponential}({\lambda=1})
\end{align*}
$$</p>
<p>Where $i$ indexes each policy, $C$ and $S$ represent the <em>observed</em> claim count and total loss amount, respectively, and $\text{E}$ represents the policy exposure. By multiplying $\lambda$ and $\text{E}$, we assume that the total number of claims is the policy exposure times the claim frequency, defined as the number of claims per unit of exposure, so we can interpret $\lambda$ as the policy&rsquo;s estimated claim frequency. We set the mean of the Exponential distribution for $S$ to be the observed claim amount $C$ times $\mu$, so we can similarly interpret $\mu$ as the policy&rsquo;s estimated claim severity, the amount of loss dollars incurred per claim.</p>
<p>We can express this in pymc as follows. Note that we only apply the likelihood for the loss amount when it is above 0, because a total loss amount of 0 doesn&rsquo;t tell us anything about the <em>severity</em> for the policy, as that happens when we have 0 claims. So, a 0 claim count is informative for our estimate of the claim frequency, but gives us no information about that policy&rsquo;s claim severity, since we didn&rsquo;t actually observe any losses. This becomes a key aspect of how this model works: for claims where we haven&rsquo;t observed any losses we can still take a guess at its claim severity because of the hyperprior.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>N <span style="color:#f92672">=</span> len(df_sample)
</span></span><span style="display:flex;"><span>E <span style="color:#f92672">=</span> df_sample[<span style="color:#e6db74">&#34;Exposure&#34;</span>]<span style="color:#f92672">.</span>to_numpy()
</span></span><span style="display:flex;"><span>C <span style="color:#f92672">=</span> df_sample[<span style="color:#e6db74">&#34;ClaimNb&#34;</span>]<span style="color:#f92672">.</span>to_numpy()
</span></span><span style="display:flex;"><span>S <span style="color:#f92672">=</span> df_sample[<span style="color:#e6db74">&#34;ClaimAmount&#34;</span>]<span style="color:#f92672">.</span>to_numpy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> pm<span style="color:#f92672">.</span>Model() <span style="color:#66d9ef">as</span> model:
</span></span><span style="display:flex;"><span>    phi <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Exponential(<span style="color:#e6db74">&#34;phi&#34;</span>, lam<span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span>)
</span></span><span style="display:flex;"><span>    omega <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Exponential(<span style="color:#e6db74">&#34;omega&#34;</span>, lam<span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lam <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Exponential(<span style="color:#e6db74">&#34;lambda&#34;</span>, lam<span style="color:#f92672">=</span>phi, shape<span style="color:#f92672">=</span>N)
</span></span><span style="display:flex;"><span>    mu <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Exponential(<span style="color:#e6db74">&#34;mu&#34;</span>, lam<span style="color:#f92672">=</span>omega, shape<span style="color:#f92672">=</span>N)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    c_obs <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Poisson(<span style="color:#e6db74">&#34;C&#34;</span>, mu<span style="color:#f92672">=</span>E <span style="color:#f92672">*</span> lam, observed<span style="color:#f92672">=</span>C)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mask <span style="color:#f92672">=</span> S <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    severity_rate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> (mu[mask] <span style="color:#f92672">*</span> C[mask])
</span></span><span style="display:flex;"><span>    s_obs <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Exponential(<span style="color:#e6db74">&#34;S&#34;</span>, lam<span style="color:#f92672">=</span>severity_rate, observed<span style="color:#f92672">=</span>S[mask])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    trace <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>sample(draws<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, tune<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, chains<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>    trace<span style="color:#f92672">.</span>extend(pm<span style="color:#f92672">.</span>sample_posterior_predictive(trace))
</span></span><span style="display:flex;"><span>    trace<span style="color:#f92672">.</span>extend(pm<span style="color:#f92672">.</span>compute_log_likelihood(trace))
</span></span></code></pre></div><p>We can then look at some model diagnostics to see if our MCMC converged well. First, we can look at the chain samples and posterior distribution for our hyperprior variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>az<span style="color:#f92672">.</span>plot_trace(trace, var_names<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;phi&#34;</span>, <span style="color:#e6db74">&#34;omega&#34;</span>])
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./insurance_resampling_8_1.png#center"/> 
</figure>

<p>$\omega$ is not sampling as well as $\phi$ but it looks okay.</p>
<p>Next we can then visualize the energy transition distribution to see if it looks okay:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>az<span style="color:#f92672">.</span>plot_energy(trace)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./insurance_resampling_10_1.png#center"/> 
</figure>

<p>And the two distributions match, meaning we expect it to have adequately explored the posterior space.</p>
<p>Now, let&rsquo;s look at some diagnostics related to the posterior predictive distributions of $C$ and $S$. First, we expect, a priori, higher exposure policies to contain more information. This is because of a natural assumption about insurance policies that they can be &ldquo;decomposed&rdquo; in a certain sense. Here, our exposure is car-years, meaning that if a policy has an exposure of 2, that could be 2 cars for 1 year, or 1 car for 2 years, or some combination. So, one can think of a policy with exposure 2 as being equivalent, from a risk standpoint, as 2 policies both with exposure 1. Holding policy characteristics constant, and glossing over details of deductibles and whatnot, there&rsquo;s no difference between a single policy covering 2 vehicles and 2 separate policies each covering one of them, the expected losses are the same. You can think through the same logic for home insurance and the like.</p>
<p>So, if we think of exposure in this way, it means that policies can be thought of as sums of random variables where each random variable represents a risk with unit exposure. Focusing on claim counts, imagine each of these unit exposure random variables follows a Poisson distribution with mean $\mu$. Then, the total expected claim count for a policy with exposure $N$ is simply $\mu * N$, and, more importantly, the variance of the mean is $\frac{\mu}{\sqrt{N}}$ (from the fact that the variance and mean of a Poisson distribution are equal). Therefore, as $N$, total exposure, increases, we expect the variance of our estimate of the expected total claim count to go down. With some mathematical rearrangement you can see that this same idea applies to an estimate of the claim frequency rather than just total number of claims. Regardless, we can just see if this is true from our posterior samples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>stats<span style="color:#f92672">.</span>pearsonr(df_sample[<span style="color:#e6db74">&#34;Exposure&#34;</span>], az<span style="color:#f92672">.</span>extract(trace, var_names<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;lambda&#34;</span>])<span style="color:#f92672">.</span>var(axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
</span></span></code></pre></div><pre><code>PearsonRResult(statistic=np.float64(-0.2568976199074987), pvalue=np.float64(3.488038665730237e-76))
</code></pre>
<p>Here we are measuring the degree of correlation between the exposure values and the variance of the samples for the claim frequency for each policy. The negative correlation we observe is exactly as we&rsquo;d expect: larger exposure policies have a lower variance in their estimated claim frequency.</p>
<p>Next, we can compare the total number of claims in the dataset to our posterior distribution of the same. We expect the observed number of claims to fall in some high probability region of our posterior, which tells us that what we observe matches up with what the model is telling us:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>hist(az<span style="color:#f92672">.</span>extract(trace<span style="color:#f92672">.</span>posterior_predictive, var_names<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;C&#34;</span>])<span style="color:#f92672">.</span>sum(axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>), bins<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grey&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(df_sample[<span style="color:#e6db74">&#34;ClaimNb&#34;</span>]<span style="color:#f92672">.</span>sum(), color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;red&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Total Number of Claims&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Density&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Histogram of Sampled Claim Counts&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend([<span style="color:#e6db74">&#34;Observed Total&#34;</span>, <span style="color:#e6db74">&#34;Sampled Data&#34;</span>])
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./insurance_resampling_14_1.png#center"/> 
</figure>

<p>We can see that things look quite reasonable.</p>
<p>We can do the same analysis for the total loss:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>hist(az<span style="color:#f92672">.</span>extract(trace<span style="color:#f92672">.</span>posterior_predictive, var_names<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;S&#34;</span>])<span style="color:#f92672">.</span>sum(axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>), bins<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grey&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(df_sample[<span style="color:#e6db74">&#34;ClaimAmount&#34;</span>]<span style="color:#f92672">.</span>sum(), color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;red&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Total Loss Amount&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Density&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Histogram of Sampled Loss Amounts&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend([<span style="color:#e6db74">&#34;Observed Total&#34;</span>, <span style="color:#e6db74">&#34;Sampled Data&#34;</span>])
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./insurance_resampling_16_1.png#center"/> 
</figure>

<p>Our observed total loss amount lies a little to the right of the mode of our posterior distribution, but still lies in a reasonable area.</p>
<p>Next, let&rsquo;s compare the posterior claim frequency of a policy where we actually have observed claims to one where we observe zero claims:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Comparing the posterior distributions of policies with high/low observed frequency</span>
</span></span><span style="display:flex;"><span>lam_sample <span style="color:#f92672">=</span> az<span style="color:#f92672">.</span>extract(trace, var_names<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;lambda&#34;</span>)
</span></span><span style="display:flex;"><span>high_claim <span style="color:#f92672">=</span> lam_sample[df_sample[<span style="color:#e6db74">&#34;ClaimNb&#34;</span>]<span style="color:#f92672">.</span>to_numpy()<span style="color:#f92672">.</span>argmax()]
</span></span><span style="display:flex;"><span>low_claim <span style="color:#f92672">=</span> lam_sample[df_sample[<span style="color:#e6db74">&#34;ClaimNb&#34;</span>]<span style="color:#f92672">.</span>to_numpy()<span style="color:#f92672">.</span>argmin()]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>hist(high_claim, bins<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>hist(low_claim, bins<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;red&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(high_claim<span style="color:#f92672">.</span>mean(), color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(low_claim<span style="color:#f92672">.</span>mean(), color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;red&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Sampled Frequency&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Density&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend([<span style="color:#e6db74">&#34;High Obs Claims&#34;</span>, <span style="color:#e6db74">&#34;Low Obs Claims&#34;</span>])
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./insurance_resampling_18_1.png#center"/> 
</figure>

<p>You can see that, as we&rsquo;d expect, when we have actually observed claims for a policy, our estimate of its claim frequency goes up.</p>
<p>From these basic diagnostics, we can see that our model reflects the stylized facts of insurance data that we expect to see. Note that this is a very simple model, you can increase the complexity from here. For example, this model assumes that our estimate of the true latent frequency and severity depends <em>only</em> upon our observed values for each, and no other policy characteristics. You can easily see how other specific information about the claim would affect your guess of its true frequency or severity.</p>
<h1 id="predictive-model-and-lift-charts">Predictive Model and Lift Charts<a hidden class="anchor" aria-hidden="true" href="#predictive-model-and-lift-charts">#</a></h1>
<p>I want to demonstrate one potentially useful application of a model like this, which is putting error bounds on lift charts. Typically, in insurance modeling applications, you create a lift chart that compares your modeled predictions of total claims or losses to the actually observed quantities. However, as we said at the beginning, the observed quantities only represent a single observation per policy. By using the posterior we computed above, we can now compute an expected <em>range</em> of observed claims and losses, so we can add some error bars to our lift chart, which lets us see probabilistically how our predictions stack up.</p>
<p>Model predictions and actual observations will never perfectly match up on a lift chart, so a natural question to ask is: how far away can my predicted quantity be from the observed before it&rsquo;s unreasonable? And that question is what the lift chart I develop below is able to give some clue to.</p>
<p>First, we develop a very basic lightgbm model to predict claim counts given the policy-specific characteristics in the dataset:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>transformer <span style="color:#f92672">=</span> make_column_transformer(
</span></span><span style="display:flex;"><span>    (
</span></span><span style="display:flex;"><span>        OrdinalEncoder(handle_unknown<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;use_encoded_value&#34;</span>, unknown_value<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>nan),
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#34;Area&#34;</span>, <span style="color:#e6db74">&#34;VehBrand&#34;</span>, <span style="color:#e6db74">&#34;VehGas&#34;</span>, <span style="color:#e6db74">&#34;Region&#34;</span>],
</span></span><span style="display:flex;"><span>    ),
</span></span><span style="display:flex;"><span>    (<span style="color:#e6db74">&#34;passthrough&#34;</span>, [<span style="color:#e6db74">&#34;Exposure&#34;</span>, <span style="color:#e6db74">&#34;VehPower&#34;</span>, <span style="color:#e6db74">&#34;VehAge&#34;</span>, <span style="color:#e6db74">&#34;DrivAge&#34;</span>, <span style="color:#e6db74">&#34;BonusMalus&#34;</span>, <span style="color:#e6db74">&#34;Density&#34;</span>]),
</span></span><span style="display:flex;"><span>    remainder<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;drop&#34;</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> transformer<span style="color:#f92672">.</span>fit_transform(df)
</span></span><span style="display:flex;"><span>y <span style="color:#f92672">=</span> df[<span style="color:#e6db74">&#34;ClaimNb&#34;</span>]<span style="color:#f92672">.</span>to_numpy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>train_X, val_X, train_y, val_y <span style="color:#f92672">=</span> train_test_split(X, y, test_size<span style="color:#f92672">=</span><span style="color:#ae81ff">0.20</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>claims_model <span style="color:#f92672">=</span> lgb<span style="color:#f92672">.</span>LGBMRegressor(
</span></span><span style="display:flex;"><span>    learning_rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.1</span>,
</span></span><span style="display:flex;"><span>    n_estimators<span style="color:#f92672">=</span><span style="color:#ae81ff">10000</span>,
</span></span><span style="display:flex;"><span>    objective<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;poisson&#34;</span>,
</span></span><span style="display:flex;"><span>    subsample<span style="color:#f92672">=</span><span style="color:#ae81ff">0.50</span>,
</span></span><span style="display:flex;"><span>    subsample_freq<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    colsample_bytree<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>,
</span></span><span style="display:flex;"><span>    max_depth<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span>,
</span></span><span style="display:flex;"><span>    num_leaves<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">6</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    extra_trees<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>claims_model<span style="color:#f92672">.</span>fit(
</span></span><span style="display:flex;"><span>    train_X,
</span></span><span style="display:flex;"><span>    train_y,
</span></span><span style="display:flex;"><span>    eval_set<span style="color:#f92672">=</span>(val_X, val_y),
</span></span><span style="display:flex;"><span>    callbacks<span style="color:#f92672">=</span>[lgb<span style="color:#f92672">.</span>early_stopping(stopping_rounds<span style="color:#f92672">=</span><span style="color:#ae81ff">50</span>)],
</span></span><span style="display:flex;"><span>    categorical_feature<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>],
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>We can look at some SHAP scatter charts to get a sense of how our input variables affect our predictions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> shap
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>explainer <span style="color:#f92672">=</span> shap<span style="color:#f92672">.</span>TreeExplainer(claims_model<span style="color:#f92672">.</span>booster_, feature_names<span style="color:#f92672">=</span>transformer<span style="color:#f92672">.</span>get_feature_names_out())
</span></span><span style="display:flex;"><span>shap_values <span style="color:#f92672">=</span> explainer(val_X[: int(len(val_X) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.10</span>)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>shap<span style="color:#f92672">.</span>plots<span style="color:#f92672">.</span>scatter(
</span></span><span style="display:flex;"><span>    shap_values[:, [<span style="color:#e6db74">&#34;passthrough__Exposure&#34;</span>, <span style="color:#e6db74">&#34;passthrough__DrivAge&#34;</span>, <span style="color:#e6db74">&#34;passthrough__BonusMalus&#34;</span>]], shap_values
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./insurance_resampling_23_0.png#center"/> 
</figure>

<p>Then, we can assemble our values for the lift chart. First we compute our quantile bin cutoffs, and then for each bin we compute the total predicted claim count plus some estimated quantiles of observed claim counts using the posterior distribution from the inference model:</p>
<p>(Note that the searchsorted trick here is quite nice. The list of quantiles is sorted by definition, and searchsorted returns the index of the quantiles array for each value of the predictions array that value would have to be placed to maintain its order. So, for instance if quantiles is [1, 2], then any prediction &lt;= 1 would be assigned index 0, anything &gt;1 but &lt;= 2 would be assigned index 1, and anything greater than 2 would be assigned index 2. So, to find all values in the predictions array that are in the first quantile bin, i.e. &lt;1, we just have to find which elements of the array returned by searchsorted are equal to 0, as so on for the other bins.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>predictions <span style="color:#f92672">=</span> claims_model<span style="color:#f92672">.</span>predict(transformer<span style="color:#f92672">.</span>transform(df_sample))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>qs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, endpoint<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>quantiles <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(predictions, qs)
</span></span><span style="display:flex;"><span>sampled_freqs <span style="color:#f92672">=</span> az<span style="color:#f92672">.</span>extract(trace, group<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;posterior&#34;</span>, var_names<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;lambda&#34;</span>)
</span></span><span style="display:flex;"><span>exposures <span style="color:#f92672">=</span> df_sample[<span style="color:#e6db74">&#34;Exposure&#34;</span>]<span style="color:#f92672">.</span>to_numpy()
</span></span><span style="display:flex;"><span>actual_claims <span style="color:#f92672">=</span> df_sample[<span style="color:#e6db74">&#34;ClaimNb&#34;</span>]<span style="color:#f92672">.</span>to_numpy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>results <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> idx <span style="color:#f92672">in</span> range(len(quantiles) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># This searchsorted trick is quite clever:</span>
</span></span><span style="display:flex;"><span>    subset_idx <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>searchsorted(quantiles, predictions) <span style="color:#f92672">==</span> idx
</span></span><span style="display:flex;"><span>    claims_subset <span style="color:#f92672">=</span> actual_claims[subset_idx]
</span></span><span style="display:flex;"><span>    freqs_subset <span style="color:#f92672">=</span> sampled_freqs[subset_idx]
</span></span><span style="display:flex;"><span>    exposures_subset <span style="color:#f92672">=</span> exposures[subset_idx]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    results[idx] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;predicted&#34;</span>: claims_subset<span style="color:#f92672">.</span>sum(),
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Note that these calculations are the same as multiplying all of the sampled freqs and exposures together and then taking the quantile</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;q25&#34;</span>: (np<span style="color:#f92672">.</span>quantile(freqs_subset, <span style="color:#ae81ff">0.25</span>, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> exposures_subset)<span style="color:#f92672">.</span>sum(),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;median&#34;</span>: (np<span style="color:#f92672">.</span>quantile(freqs_subset, <span style="color:#ae81ff">0.50</span>, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> exposures_subset)<span style="color:#f92672">.</span>sum(),
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;q75&#34;</span>: (np<span style="color:#f92672">.</span>quantile(freqs_subset, <span style="color:#ae81ff">0.75</span>, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> exposures_subset)<span style="color:#f92672">.</span>sum(),
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bins <span style="color:#f92672">=</span> sorted(list(results<span style="color:#f92672">.</span>keys()))
</span></span><span style="display:flex;"><span>x_positions <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(len(bins))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>medians <span style="color:#f92672">=</span> [results[bin_idx][<span style="color:#e6db74">&#34;median&#34;</span>] <span style="color:#66d9ef">for</span> bin_idx <span style="color:#f92672">in</span> bins]
</span></span><span style="display:flex;"><span>q25s <span style="color:#f92672">=</span> [results[bin_idx][<span style="color:#e6db74">&#34;q25&#34;</span>] <span style="color:#66d9ef">for</span> bin_idx <span style="color:#f92672">in</span> bins]
</span></span><span style="display:flex;"><span>q75s <span style="color:#f92672">=</span> [results[bin_idx][<span style="color:#e6db74">&#34;q75&#34;</span>] <span style="color:#66d9ef">for</span> bin_idx <span style="color:#f92672">in</span> bins]
</span></span><span style="display:flex;"><span>predictions <span style="color:#f92672">=</span> [results[bin_idx][<span style="color:#e6db74">&#34;predicted&#34;</span>] <span style="color:#66d9ef">for</span> bin_idx <span style="color:#f92672">in</span> bins]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ranges <span style="color:#f92672">=</span> ax<span style="color:#f92672">.</span>vlines(
</span></span><span style="display:flex;"><span>    x_positions, q25s, q75s, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;cornflowerblue&#34;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.7</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;25th-75th Percentile Range&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>median_dots <span style="color:#f92672">=</span> ax<span style="color:#f92672">.</span>scatter(x_positions, medians, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;navy&#34;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">80</span>, zorder<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Median&#34;</span>)
</span></span><span style="display:flex;"><span>pred_dots <span style="color:#f92672">=</span> ax<span style="color:#f92672">.</span>scatter(x_positions, predictions, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;crimson&#34;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;X&#34;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>, zorder<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Predicted&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_xticks(x_positions)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_xticklabels([<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Bin </span><span style="color:#e6db74">{</span>bin_idx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> <span style="color:#66d9ef">for</span> bin_idx <span style="color:#f92672">in</span> bins])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;Bin&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;Total Claims&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;Predicted Values vs. Quantile Ranges by Bin&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>legend(handles<span style="color:#f92672">=</span>[ranges, median_dots, pred_dots], loc<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;upper left&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>grid(<span style="color:#66d9ef">True</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;--&#34;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.7</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_axisbelow(<span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout()
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="./insurance_resampling_26_0.png#center"/> 
</figure>

<p>Here we can see that for each bin, we marked the model predicted total claim count, as well as the 25th, median, and 75th percentile total claim counts computed from our inference model. We can see that for bins 0 through 3, our predictions sit nicely towards the middle of the expected claims distribution. However, for bin 4, our predicted values lies past the quantile boundaries, meaning that we over-predict claim counts for policies in that bin.</p>
<p>This kind of visualization gives you more information about how reasonable your predicted values are compared to the entire posterior distribution of observed claims. Of course, you can do the same kind of thing for total losses, severity, etc. See, for instance, that in bin 1 our predicted value does get away from the median moreso than some of the other bins, but the quantile boundaries tell you that it&rsquo;s not really that off.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>Hopefully this is illustrative, but I think a model like this is very useful for placing your expectations about your historical policy experience in a nice framework. I don&rsquo;t think what we actually observed in the past is the end of the story for insurance, even putting aside development issues, which is another thing you could expand this model to incorporate. The past only gives us a single pass of experience, but we can still use that information to make pretty good guesses about what could have happened.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://eadains.github.io/OptionallyBayesHugo/tags/python/">Python</a></li>
      <li><a href="http://eadains.github.io/OptionallyBayesHugo/tags/bayesian/">Bayesian</a></li>
      <li><a href="http://eadains.github.io/OptionallyBayesHugo/tags/insurance/">Insurance</a></li>
      <li><a href="http://eadains.github.io/OptionallyBayesHugo/tags/pymc/">Pymc</a></li>
      <li><a href="http://eadains.github.io/OptionallyBayesHugo/tags/arviz/">Arviz</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://eadains.github.io/OptionallyBayesHugo/">Optionally Bayes</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
